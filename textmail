#!/usr/bin/perl -w
use strict;

# textmail - mail filter to replace MS Word/HTML attachments with plain text
#
# Copyright (C) 2003-2005 raf <raf@raf.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# or visit http://www.gnu.org/copyleft/gpl.html
#
# 20050419 raf <raf@raf.org>

=head1 NAME

I<textmail> - mail filter to replace MS Word/HTML attachments with plain text

=head1 SYNOPSIS

 usage: formail -s textmail [options]
 options:
   -h       - Print the help message then exit
   -m       - Print the manpage then exit
   -w       - Print the manpage in html format then exit
   -r       - Print the manpage in nroff format then exit
   -M       - Output in mailbox format
   -W       - Don't replace MS Word attachments with text
   -E       - Don't replace MS Excel attachments with csv
   -H       - Don't replace HTML attachments with text
   -R       - Don't replace RTF attachments with text
   -P       - Don't replace PDF attachments with text
   -U       - Don't translate winmail.dat attachments
   -L       - Don't reduce appledouble attachments
   -I       - Don't delete image attachments
   -A       - Don't delete audio attachments
   -V       - Don't delete video attachments
   -X       - Don't delete MS Windows executable attachments
   -B       - Don't recode text that was base64-encoded
   -O       - Delete all application/octet-stream attachments
   -!       - Delete all application/* attachments
   -D hdrs  - Delete headers (list of header prefixes and filenames)
   -K types - Keep attachments (list of mimetypes and filenames)
   -f       - On translation error, keep translation, not original
   -?       - Print paths of helper applications then exit

=head1 DESCRIPTION

I<textmail(1)> filters a mail message, replacing MS Word, MS Excel, HTML,
RTF and PDF attachments with the plain text contained therein. By default,
the following attachments are also deleted: image, audio, video and MS
Windows executables. MS winmail.dat attachments are replaced by their
contents which are then replaced by text or deleted in the same fashion.
Any of these actions can be suppressed with the command line options.

This is useful for increasing the accessibility of mail messages (by
reducing their dependence on proprietary file formats), for dramatically
reducing their size (and the time it takes to download them and the time it
takes to read them), and for dramatically reducing the risk of mail-bourne
viruses). Its intended use is as a preprocessor for mailing lists. This is
more friendly than a strict "No Attachments" policy.

=head1 OPTIONS

=over 4

=item C<-h>

Print the help message then exit.

=item C<-m>

Print the manpage then exit. This is equivalent to executing C<man textmail>
but this works even when the manpage isn't installed properly.

=item C<-w>

Print the manpage in html format then exit. This lets you install the
manpage in html format with a command like:

  mkdir -p /usr/local/share/doc/textmail/html &&
  textmail -w > /usr/local/share/doc/textmail/html/textmail.1.html

=item C<-r>

Print the manpage in nroff format then exit. This lets you install the
manpage properly with a command like:

  textmail -r > /usr/local/share/man/man1/textmail.1

=item C<-M>

This option adds a mailbox C<From> line at the top and ensures that there is
a blank line at the bottom of the output. Only use this when the output is
to be stored in a mailbox file. It is not necessary when the output is to be
sent to an SMTP server.

=item C<-W>

By default, I<textmail(1)> replaces MS Word attachments with inline plain
text attachments that contain just the plain text within the original
document. This option leaves MS Word attachments intact.

=item C<-E>

By default, I<textmail(1)> replaces MS Excel attachments with CSV file
attachments that contain just the data within the original document. This
option leaves MS Excel attachments intact.

=item C<-H>

By default, I<textmail(1)> replaces HTML attachments with inline plain text
attachments that contain just the text within the original document. It also
reduces text-versus-html alternative attachments to just the text
attachment. This option leaves HTML (and alternative) attachments intact.

=item C<-R>

By default, I<textmail(1)> replaces RTF attachments with inline plain text
attachments that contain just the plain text within the original document.
This option leaves RTF attachments intact.

=item C<-P>

By default, I<textmail(1)> replaces PDF attachments with inline plain text
attachments that contain just the plain text within the original document.
This option leaves PDF attachments intact.

=item C<-U>

By default, I<textmail(1)> replaces MS TNEF (i.e. C<winmail.dat>)
attachments with the attachments contained therein which are then translated
to text as normal. This option leaves C<winmail.dat> attachments intact.
This option, together with the C<-!> option will cause winmail.dat
attachments to be deleted.

=item C<-L>

By default, I<textmail(1)> replaces C<multipart/appledouble> attachments
with just the data fork attachment contained therein which is then
translated to text as normal. This option leaves appledouble attachments
intact. However, the data fork attachment will still be translated as normal
resulting in a probably inappropriate and possibly broken resource fork
attachment. Therefore, this option should probably only be used in
conjunction with other options that suppress translation of the data fork
attachment.

=item C<-I>

By default, I<textmail(1)> deletes image attachments. This option leaves
image attachments intact.

=item C<-A>

By default, I<textmail(1)> deletes audio attachments. This option leaves
audio attachments intact.

=item C<-V>

By default, I<textmail(1)> deletes video attachments. This option leaves
video attachments intact.

=item C<-X>

By default, I<textmail(1)> deletes attachments containing MS Windows
executables. That means, C<application/octet-stream> attachments with the
following filename extensions: C<com>, C<exe>, C<pif>, C<dll>, C<ocx>,
C<scr>, C<vbs> and C<js>. This option leaves MS Windows executable
attachments intact.

=item C<-B>

By default, when text is encountered that is base64-encoded, I<textmail(1)>
will recode it as either C<7bit> or C<quoted-printable>, whichever is
appropriate. This option suppresses this recoding.

=item C<-O>

Delete all C<application/octet-stream> attachments, not just MS Windows
executables. Note that this overrides C<-X> but C<-K> overrides this.

=item C<-!>

Delete all C<application/*> attachments. Note that this overrides C<-X> but
C<-K> overrides this. Also note that translated documents are no longer
C<application/*> attachments so they aren't deleted unless their translation
is suppressed with the appropriate command line option.

=item C<-D> I<hdrs>

Delete particular headers. The I<hdrs> argument is a comma separated list of
header name prefixes and/or the names of files containing header name
prefixes (blank lines, whitespace and shell style comments are ignored). For
example, C<textmail -DX-> deletes all headers whose names begin with C<X->.

=item C<-K> I<types>

By default, I<textmail(1)> deletes several types of non-text attachment. The
C<-O> and C<-!> options delete even more. This option specifies, by mimetype
and/or filename extension, a list of attachments not to delete. This
overrides all deletions.

The I<types> argument is a comma separated list of mimetypes and/or filename
extensions and/or the names of files containing mimetypes and/or filename
extensions (blank lines, whitespace and shell style comments are ignored).
Note that the elements are interpreted as a complete mimetype, if they
contain a slash character, or as either the C<*> in C<application/*> or as a
filename extension if they do not contain a slash character. For example,
C<textmail -Wf!Kdoc> deletes all C<application/*> attachments except MS Word
documents.

=item C<-f>

Whenever I<textmail(1)> is unable to translate any attachment into text, it
will leave the attachment intact. This happens when the requisite
translation software can't be found, when it runs but returns an error code,
and when it produces an empty file. This option causes the empty translation
to take the place of the original attachment. Only the name of the
attachment is preserved. This is needed to ensure plain text even in the
face of an MS Word document that contains no text (e.g. only images and/or
viruses).

=item C<-?>

Print the paths of all helper applications then exit.

=back

=head1 EXAMPLES

A I<procmail(1)> recipe that insists on pure text and no C<X-> headers (with
output in mailbox format):

  :0 fw
  | textmail -Mf!DX-

Do the same but to an existing mailbox file:

  formail -s textmail -Mf!DX- < mailbox > mailbox-as-text

Delete all C<application/*> attachments except for PostScript and PDF (and
don't translate the PDF into text):

  textmail -!PKps,pdf

Delete all C<application/*> attachments except for zip files and gzipped tar
files:

  textmail -!Ktar.gz,zip

A I<procmail(1)> recipe that just unpacks winmail.dat attachments but
doesn't translate the attachments contained therein into text and doesn't
delete windows executables (with output in mailbox format):

  :0 fw
  | textmail -MWEHRPLIAVX

=head1 REQUIREMENTS

MS Word and RTF documents are translated into plain text using I<catdoc(1)>.
If I<textmail(1)> can't find I<catdoc(1)>, then MS Word and RTF attachments
are left intact. So make sure that I<catdoc(1)> is installed and in the
C<$PATH>.

MS Excel documents are translated into csv files using I<xls2csv(1)>. If
I<textmail(1)> can't find I<xls2csv(1)>, then MS Excel attachments are left
intact. So make sure that I<xls2csv(1)> is installed and in the C<$PATH>.

HTML documents are translated into plain text using I<lynx(1)>. If
I<textmail(1)> can't find I<lynx(1)>, then HTML attachments are left intact.
So make sure that I<lynx(1)> is installed and in the C<$PATH>.

PDF documents are translated into plain text using I<pdftotext(1)>. If
I<textmail(1)> can't find I<pdftotext(1)>, then PDF attachments are left
intact. So make sure that I<pdftotext(1)> is installed and in the C<$PATH>.

I<textmail(1)> also requires I<perl(1)>, the I<MIME::Tools(3)> package,
I<pod2man(1)>, I<pod2html(1)> and I<mktemp(1)>.

If I<textmail(1)> fails to create a temporary directory, or if it is
instructed to do nothing (i.e. C<-WEHRPULIAVX>), then it degenerates into
I<cat(1)>.

=head1 CAVEAT

If I<textmail(1)> is unable to create a temporary directory (in C</tmp>),
then it degenerates into I<cat(1)>. This means that without a temporary
directory, no attachments will be translated or deleted no matter what
options (even C<-f>) were given to I<textmail(1)>. So make sure that C</tmp>
is writable. Also make sure that I<mktemp(1)> is available otherwise an
insecure temporary directory will be created.

=head1 BUGS

Any existing mailbox C<"From "> header is lost forever. The C<-M> option
creates a new mailbox C<"From "> header using the sender of the message
(if present) and the current time as the timestamp. Does this matter?

This isn't fast enough to handle high volumes of mail. Loading the
C<MIME::Parser> module takes 0.7 seconds on my slow (450MHz) machine.
On a fast machine, it might be able to handle 10 messages per second.

=head1 SEE ALSO

I<procmail(1)>,
I<formail(1)>,
I<catdoc(1)>,
I<xls2csv(1)>,
I<lynx(1)>,
I<pdftotext(1)>,
I<MIME::Tools(3)>,
I<pod2man(1)>,
I<pod2html(1)>

=head1 AUTHOR

20050419 raf <raf@raf.org>

=head1 URL

C<http://raf.org/textmail/>

=cut

# Doco functions: usage and manpage (via $PAGER or as nroff or html)

sub help
{
	print
		"usage: formail -s textmail [options]\n",
		"options:\n",
		"  -h       - Print the help message then exit\n",
		"  -m       - Print the manpage then exit\n",
		"  -w       - Print the manpage in html format then exit\n",
		"  -r       - Print the manpage in nroff format then exit\n",
		"  -M       - Output in mailbox format\n",
		"  -W       - Don't replace MS Word attachments with text\n",
		"  -E       - Don't replace MS Excel attachments with csv\n",
		"  -H       - Don't replace HTML attachments with text\n",
		"  -R       - Don't replace RTF attachments with text\n",
		"  -P       - Don't replace PDF attachments with text\n",
		"  -U       - Don't translate winmail.dat attachments\n",
		"  -L       - Don't reduce appledouble attachments\n",
		"  -I       - Don't delete image attachments\n",
		"  -A       - Don't delete audio attachments\n",
		"  -V       - Don't delete video attachments\n",
		"  -X       - Don't delete MS Windows executable attachments\n",
		"  -B       - Don't recode text that was base64-encoded\n",
		"  -O       - Delete all application/octet-stream attachments\n",
		"  -!       - Delete all application/* attachments\n",
		"  -D hdrs  - Delete headers (list of header prefixes and filenames)\n",
		"  -K types - Keep attachments (list of mimetypes and filenames)\n",
		"  -f       - On translation error, keep translation, not original\n",
		"  -?       - Print paths of helper applications then exit\n",
		"\n",
		"Filters a mail message, replacing MS Word, MS Excel, HTML, RTF and PDF\n",
		"attachments with the plain text contained therein. By default, the\n",
		"following attachments are also deleted: image, audio, video and MS\n",
		"Windows executables. MS winmail.dat attachments are replaced by their\n",
		"contents which are then replaced by text or deleted in the same fashion.\n";
	exit;
}


sub man
{
	my $noquotes = (`pod2man -h 2>&1` =~ /--quotes=/) ? '--quotes=none' : '';
	system "pod2man $noquotes $0 | nroff -man | " . ($ENV{PAGER} || 'more');
	exit;
}

sub nroff
{
	my $noquotes = (`pod2man -h 2>&1` =~ /--quotes=/) ? '--quotes=none' : '';
	system "pod2man $noquotes $0";
	exit;
}

sub html
{
	system "pod2html --noindex $0";
	unlink glob 'pod2htm*';
	exit;
}

# Default mimetypes for unpacking winmail.dat (augmented by /etc/mime.types)

my %type =
(
	txt => 'text/plain',
	csv => 'text/plain',
	htm => 'text/html',
	gif => 'image/gif',
	jpg => 'image/jpeg',
	png => 'image/png',
	bmp => 'image/bmp',
	tif => 'image/tiff',
	rtf => 'application/rtf',
	doc => 'application/vnd.ms-word',
	wri => 'application/vnd.ms-word',
	xls => 'application/vnd.ms-excel',
	ppt => 'application/vnd.ms-powerpoint',
	pdf => 'application/pdf',
	ps => 'application/ps',
	eps => 'application/ps',
	zip => 'application/zip',
	mp3 => 'audio/mpeg',
	wav => 'audio/wav',
	mpg => 'video/mpeg',
	avi => 'video/x-msvideo',
	vcf => 'text/x-vcard',
	other => 'application/octet-stream'
);

# Initialize

my %opt;
use Getopt::Std;
help unless getopts 'hmrwMWEHRPLUIAVXBO!D:K:f?', \%opt;
help if exists $opt{h};
man if exists $opt{m};
nroff if exists $opt{r};
html if exists $opt{w};
my $mailbox = exists $opt{M};
my $catdoc = find('catdoc');
my $xls2csv = find('xls2csv');
my $lynx = find('lynx');
my $pdftotext = find('pdftotext');
my $mktemp = find('mktemp');
paths() if exists $opt{'?'};
my @exe = qw(com exe pif dll ocx scr vbs js);
my $force = exists $opt{f};
my $remove_word = (defined $catdoc || $force) && ! exists $opt{W};
my $remove_excel = (defined $xls2csv || $force) && ! exists $opt{E};
my $remove_html = (defined $lynx || $force) && ! exists $opt{H};
my $remove_rtf = (defined $catdoc || $force) && ! exists $opt{R};
my $remove_pdf = (defined $pdftotext || $force) && ! exists $opt{P};
my $remove_tnef = ! exists $opt{U};
my $remove_apple = ! exists $opt{L};
my $remove_images = ! exists $opt{I};
my $remove_audio = ! exists $opt{A};
my $remove_video = ! exists $opt{V};
my $remove_exe = ! exists $opt{X};
my $recode_base64_text = ! exists $opt{B};
my $remove_octet = exists $opt{O};
my $remove_application = exists $opt{'!'};
my $remove_headers = exists $opt{D};
my @headers = get_file($opt{D}) if $remove_headers;
my $keep_attachments = exists $opt{K};
my @keep = get_file($opt{K}) if $keep_attachments;
my $removing = $remove_word || $remove_excel || $remove_html || $remove_rtf || $remove_pdf || $remove_tnef || $remove_apple || $remove_images || $remove_audio || $remove_video || $remove_exe || $recode_base64_text || $remove_octet || $remove_application || $remove_headers;
chop(my $tmp = `$mktemp -dq /tmp/textmail.XXXXXX`) if $removing && defined $mktemp;
if (!$removing || (($? || !defined $tmp || ! -d $tmp) && !mkdir($tmp = "/tmp/textmail.$$", 0700)))
{
	exec '/bin/cat' or print STDERR ''; # suppress warning
	print while (<STDIN>); # slow cat if exec fails
	exit;
};

my $attachment;
my @attachment;
my $pos = 0;
my $data;
my $index = 0;
add_mimetypes();

# Filter the mail message on stdin into text on stdout

use POSIX;
use MIME::Parser;
my $parser = new MIME::Parser;          # Create the MIME parser
$parser->output_dir($tmp);              # Tell it where to work
my $entity = $parser->parse(\*STDIN);   # Parse stdin
$entity->make_multipart;                # Make it a multipart
$entity = textmail($entity);            # Translate the message
$entity->make_singlepart;               # Reduce to singlepart
$entity->sync_headers(Nonstandard => 'ERASE', Length => 'ERASE'); # Clean up mime headers
my $out = $entity->as_string;           # Get the result as a string
$out .= "\n" unless $out =~ /\n$/;      # Guarantee a terminating newline
print($out), done() unless $mailbox;    # Print it (unless mailbox format)
print mailbox_header($entity), $out;    # Print it in mailbox format
print "\n" unless $out =~ /\n\n$/;      # Guarantee terminating blank line
done();

# Clean up on exit

sub done
{
	$entity->purge;                       # Clean up any files
	rmdir $tmp or system "rm -rf $tmp";   # Remove the directory
	exit;
}

# Print paths to help applications then exit

sub paths
{
	print(defined $catdoc ? $catdoc : "catdoc not found: MS Word and RTF will not be translated", "\n");
	print(defined $xls2csv ? $xls2csv : "xls2csv not found: MS Excel with not be translated", "\n");
	print(defined $lynx ? $lynx : "lynx not found: HTML will not be translated", "\n");
	print(defined $pdftotext ? $pdftotext : "pdftotext not found: PDF will not be translated", "\n");
	print(defined $mktemp ? $mktemp : "mktemp not found: insecure temp directory will be used", "\n");
	exit;
}

# Translate a multipart mail message

sub textmail
{
	my $entity = shift;
	my $isapart = shift || 0;
	my @parts = $entity->parts;
	my $xxx = shift || '';

	# Do nothing if this is encrypted or signed

	return $entity if isa($entity, qr/multipart\/(?:signed|encrypted)/);

	# Remove headers

	if ($remove_headers)
	{
		$entity->head->delete($_) for grep { /^(?:@{[join '|', @headers]})/i } $entity->head->tags;
	}

	if ($remove_tnef)
	{
		$entity->head->delete($_) for grep { /^(?:X-MS-TNEF-Correlator|Lines)/i } $entity->head->tags;
	}

	# Reduce alternative text-versus-html to just the text

	if ($remove_html && isa($entity, 'multipart/alternative') && @parts == 2)
	{
		if (isa($parts[0], 'text/plain') || isa($parts[1], 'text/plain'))
		{
			my $index = isa($parts[0], 'text/plain') ? 0 : 1;
			$parts[1 - $index]->bodyhandle->purge;
			my $plain = $parts[$index];
			my %mime_headers = map { ($_, $plain->head->get($_)) } grep { /^content-/i } $plain->head->tags;
			$plain->head($entity->head);
			$plain->head->replace($_, $mime_headers{$_}) for (keys %mime_headers);
			return debase64($plain);
		}
	}

	# Reduce appledouble attachments to just the data fork attachment

	if ($remove_apple && isa($entity, 'multipart/appledouble') && @parts == 2)
	{
		if (isa($parts[0], 'application/applefile'))
		{
			$parts[0]->bodyhandle->purge;
			my $data = $parts[1];
			my %mime_headers = map { ($_, $data->head->get($_)) } grep { /^content-/i } $data->head->tags;
			$data->head($entity->head);
			$data->head->replace($_, $mime_headers{$_}) for (keys %mime_headers);
			$data->make_multipart;
			$data = textmail($data, 0, $xxx.' ');
			$data->make_singlepart;
			return $data;
		}
	}

	# Process parts

	for (my $i = 0; $i < @parts; ++$i)
	{
		# Replace MS Word attachments with plain text (via catdoc)

		if ($remove_word && isa($parts[$i], qr/.*ms-?word/i, qr/\.doc$/i))
		{
			$parts[$i] = translate($parts[$i], 'doc', 'txt', $catdoc);
			next;
		}

		# Replace MS Excel attachments with csv (via xls2csv)

		if ($remove_excel && isa($parts[$i], qr/.*ms-?excel/i, qr/\.xls$/i))
		{
			$parts[$i] = translate($parts[$i], 'xls', 'csv', $xls2csv);
			next;
		}

		# Replace HTML attachments with plain text (via lynx -dump)

		if ($remove_html && isa($parts[$i], 'text/html'))
		{
			$parts[$i] = translate($parts[$i], 'html,htm', 'txt', "$lynx -dump");
			next;
		}

		# Replace RTF attachments with plain text (via catdoc)

		if ($remove_rtf && isa($parts[$i], qr/rtf/i, qr/\.rtf$/i))
		{
			$parts[$i] = translate($parts[$i], 'rtf', 'txt', $catdoc);
			next;
		}

		# Replace PDF attachments with plain text (via pdftotext)

		if ($remove_pdf && isa($parts[$i], qr/pdf/i, qr/\.pdf$/i))
		{
			$parts[$i] = translate($parts[$i], 'pdf', 'txt', $pdftotext);
			next;
		}

		# Replace TNEF attachments with the attachments contained therein

		if ($remove_tnef && isa($parts[$i], qr/ms-tnef/i, qr/winmail\.dat$/i))
		{
			splice @parts, $i, 1, unoutlook($parts[$i]);
			--$i, next;
		}

		# Remove images, audio, video, MS Windows executables, octet streams, application/*

		if (!protected($parts[$i]) &&
			($remove_images && $parts[$i]->effective_type =~ /^image\// ||
			$remove_audio && $parts[$i]->effective_type =~ /^audio\// ||
			$remove_video && $parts[$i]->effective_type =~ /^video\// ||
			$remove_exe && $parts[$i]->effective_type =~ /^application\/octet-stream/ && $parts[$i]->head->recommended_filename =~ /\.(?:@{[join '|', @exe]})(?:\?=)?$/i ||
			$remove_octet && $parts[$i]->effective_type =~ /^application\/octet-stream/ ||
			$remove_application && $parts[$i]->effective_type =~ /^application\//))
		{
			$parts[$i]->bodyhandle->purge;
			splice @parts, $i--, 1;
			next;
		}

		# Don't use base64 encoding for text

		$parts[$i] = debase64($parts[$i]);

		# Nest

		$parts[$i] = textmail($parts[$i], 1, $xxx.' ');
	}

	# Replace original parts with processed parts

	@parts = grep { $_->effective_type =~ /^(?:multipart|message)/ || (defined $_->bodyhandle && $_->bodyhandle->as_string !~ /^$/) } @parts;
	$entity->parts(\@parts);

	return $entity;
}

# Do we need to keep this attachment?

sub protected
{
	$entity = shift;

	return 0 unless @keep;

	for my $spec (map { quotemeta } @keep)
	{
		return 1 if $spec =~ /\// && $entity->effective_type =~ /^$spec/i;
		return 1 if $spec !~ /\// && $entity->effective_type =~ /^application\/$spec/i;
		return 1 if $spec !~ /\// && defined $entity->head->recommended_filename && $entity->head->recommended_filename =~ /\.$spec(?:\?=)?$/i;
	}

	return 0;
}

# Check if a part is of the desired type

sub isa
{
	my $entity = shift;
	my $type = shift;
	my $ext = shift;

	return
		$entity->effective_type =~ /$type/i ||
		$entity->effective_type =~ /^application\/$type/i ||
		$entity->effective_type =~ /^application\/octet-stream/i &&
			defined $ext && $entity->head->recommended_filename =~ /$ext/i;
}

# Return a translated part

sub translate
{
	my $part = shift;
	my @ext = split /,/, shift;
	my $fmt = shift;
	my $cmd = shift;

	my $body = $part->bodyhandle;
	my $origpath = $body->path;
	my $textpath = $origpath;
	$textpath =~ s/\.(?:@{[join '|', @ext]})$/.$fmt/i;
	my $textname = $part->head->recommended_filename;
	$textname =~ s/\.(?:@{[join '|', @ext]})((?:\?=)?)$/.$fmt$1/i if defined $textname;

	while (-f $textpath) # avoid filename clashes
	{
		if ($textpath =~ /\.(\d+)\.txt(?:\?=)?$/)
		{
			my $count = $1 + 1;
			$textpath =~ s/\.\d+\.(txt(?:\?=)?)$/.$count.$1/;
		}
		else
		{
			$textpath =~ s/\.(txt(?:\?=)?)$/.1.$1/;
		}
	}

	if ($force && !defined $cmd)
	{
		open TEXT, ">$textpath";
		close TEXT;
	}
	elsif (system($cmd . ' ' . quotemeta($origpath) . ' > ' . quotemeta($textpath)) || (-s $origpath && -z $textpath))
	{
		unless ($force)
		{
			unlink $textpath;
			return $part;
		}
	}

	$body->purge;

	return MIME::Entity->build
	(
		Disposition => ($fmt eq 'txt' ? 'inline' : 'attachment'),
		Filename => $textname,
		Path => $textpath,
		'X-Mailer' => undef # or MIME::Parser will add one
	);
}

# Recode base64-encoded text as 7bit or quoted-printable

sub debase64
{
	my $entity = shift;

	# Do we need to do anthing?

	return $entity unless $recode_base64_text;
	my $type = $entity->effective_type;
	my $encoding = $entity->head->get('Content-transfer-encoding');
	return $entity unless $type =~ /^text\//i && defined $encoding && $encoding =~ /^base64/;

	# Identify the appropriate encoding to use

	my $maxlen = 0;
	my $ascii = 0;
	my $highbit = 0;
	my $text = $entity->bodyhandle->as_string;

	for (split /[\r\n]+/, $text)
	{
		my $len = length;
		$maxlen = $len if $len > $maxlen;
		$highbit += tr/\200-\377//d;
		$ascii += length;
	}

	$encoding = ($maxlen <= 1000 && $highbit == 0) ? '7bit' : 'quoted-printable';

	$entity->head->replace('Content-Transfer-Encoding', $encoding);

	# Convert DOS text files into UNIX text files

	if ($text =~ /\r\n/ && open DATA, '>' . $entity->bodyhandle->path)
	{
		$text =~ tr/\r//d;
		print DATA $text;
		close DATA;
	}

	return $entity;
}

# Generate a mailbox "From " header

sub mailbox_header
{
	my $entity = shift;

	my $from = $entity->head->get('Sender');
	$from = $entity->head->get('From') unless defined $from;
	$from =~ s/[\r\n]+//, $from =~ s/\s*\((?:\\.|[^()])*\)\s*//g if defined $from;
	$from = 'unknown' unless defined $from;
	$from = $1 if $from =~ /<([^>]+)>/;
	$from =~ s/\s/-/g;

	return "From $from  " . ctime(time());
}

# Parse a data file

sub get_file
{
	my $spec = shift;
	my @list;

	for my $pat (split /[,\s]+/, $spec)
	{
		if (-r $pat)
		{
			open HDRS, $pat or next;

			while (<HDRS>)
			{
				s/#.*$//, s/^\s+//, s/\s+$//, next unless $_;
				push @list, $_;
			}

			close HDRS;
		}
		else
		{
			push @list, $pat;
		}
	}

	return @list;
}

# Locate a command in the $PATH

sub find
{
	my $cmd = shift;
	return $_ for (grep { -x $_ } map { "$_/$cmd" } split /:/, $ENV{PATH});
	return undef;
}

# Parse /etc/mime.types

sub add_mimetypes
{
	open M, '/etc/mime.types' or return;

	while (<M>)
	{
		s/#.*$//, s/^\s+//, s/\s+$//, next unless $_;
		my ($mimetype, $ext) = /^(\S+)\s+(.*)$/; next unless $ext;
		$type{$_} = $mimetype for split /\s+/, $ext;
	}

	close M;
}

# Return winmail.dat contents as a list of parts

sub unoutlook
{
	my $part = shift;
	my $body = $part->bodyhandle;
	my $origpath = $body->path;
	my @parts;

	++$index;
	eval { winmail($origpath, "$tmp/extract$index") };
	rmdir("$tmp/extract$index"), return () if $@;

	for my $path (glob "$tmp/extract$index/*")
	{
		my $fname = $path;
		$fname =~ s/^.*\///;
		my ($ext) = $fname =~ /\.([^.]+)$/;
		my $type = $type{$ext || 'other'} || 'applicaton/octet-stream';
		my $encoding = ($type =~ /^text\//i) ? 'quoted-printable' : 'base64';

		push @parts, MIME::Entity->build
		(
			Disposition => ($fname =~ /\.txt$/i ? 'inline' : 'attachment'),
			Filename => $fname,
			Path => $path,
			Type => $type,
			Encoding => $encoding,
			'X-Mailer' => undef # or MIME::Parser will add one
		);
	}

	$body->purge;

	return @parts;
}

# Decode a MS-TNEF winmail.dat attachment

sub MESSAGE { 1 }
sub ATTACHMENT { 2 }
sub MESSAGE_CLASS { 7 << 16 | 0x8008 }
sub ATTACH_DATA { 6 << 16 | 0x800F }
sub ATTACH_FILENAME { 1 << 16 | 0x8010 }
sub ATTACH_RENDDATA { 6 << 16 | 0x9002 }
sub VERSION { 8 << 16 | 0x9006 }

sub winmail
{
	my $winmail = shift;
	my $outdir = shift;
	@attachment = ();
	mkdir $outdir, 0777 or die "Failed to mkdir '$outdir'\n" unless -d $outdir;
	open W, $winmail or die "Failed to open '$winmail' for reading: $!\n";
	$data = do { local $/; <W> };
	close W;
	my $signature = unpack 'V', substr($data, $pos, 4); $pos += 4;
	die "Invalid mstnef signature: " . sprintf('%x', $signature) . "\n" unless $signature == 0x223E9F78;
	my $key = unpack 'v', substr($data, $pos, 2); $pos += 2;
	my $type = unpack 'C', substr($data, $pos, 1);
	die "fatal: unexpected tnef token type: '$type'\n" unless $type == MESSAGE || $type == ATTACHMENT;
	read_version();
	do {} while read_message_attribute();
	read_attribute_message_class();
	do {} while read_message_attribute();
	do {} while read_attachment_attribute();
	my $defname = 1;
	for my $a (@attachment)
	{
		my $fname = (defined $a->{filename}) ? $a->{filename} : $defname++;
		$fname =~ s/^(?:.)*[\/\\]//;
		open A, "> $outdir/$fname" or die "Failed to open '$outdir/$fname' for writing: $!\n";
		print A $a->{data};
		close A;
	}
}

sub read_version
{
	my $type = unpack 'C', substr $data, $pos, 1;
	return unless defined $type && $type == MESSAGE;
	my $version = unpack 'V', substr $data, $pos + 1, 4;
	return unless $version == VERSION; $pos += 13;
	my $chk = unpack 'v', substr $data, $pos, 2; $pos += 2;
}

sub read_attribute_message_class
{
	my $type = unpack 'C', substr $data, $pos, 1;
	return unless defined $type && $type == MESSAGE;
	my $id = unpack 'V', substr $data, $pos + 1, 4;
	return unless $id == MESSAGE_CLASS; $pos += 5;
	my $len = unpack 'V', substr $data, $pos, 4; $pos += 4;
	my $buf = substr($data, $pos, $len); $pos += $len;
	my $chk = unpack 'v', substr $data, $pos, 2; $pos += 2;
	my $tot = unpack '%16C*', $buf;
	die "error: checksum for id=$id failed: '$chk' != $tot\n" if $chk != $tot;
}

sub read_message_attribute
{
	my $type = unpack 'C', substr $data, $pos, 1;
	return 0 unless defined $type && $type == MESSAGE; ++$pos;
	my $id = unpack 'V', substr $data, $pos, 4; $pos += 4;
	my $len = unpack 'V', substr $data, $pos, 4; $pos += 4;
	my $buf = substr($data, $pos, $len); $pos += $len;
	my $chk = unpack 'v', substr $data, $pos, 2; $pos += 2;
	my $tot = unpack '%16C*', $buf;
	die "error: checksum for id=$id failed: '$chk' != $tot\n" if $chk != $tot;
	return 1;
}

sub read_attachment_attribute
{
	my $type = unpack 'C', substr $data, $pos, 1;
	return 0 unless defined $type && $type == ATTACHMENT; ++$pos;
	my $id = unpack 'V', substr $data, $pos, 4; $pos += 4;
	push @attachment, $attachment = {} if $id == ATTACH_RENDDATA;
	my $len = unpack 'V', substr $data, $pos, 4; $pos += 4;
	my $buf = substr($data, $pos, $len); $pos += $len;
	my $chk = unpack 'v', substr $data, $pos, 2; $pos += 2;
	my $tot = unpack '%16C*', $buf;
	die "error: checksum for id=$id failed: '$chk' != $tot\n" if $chk != $tot;
	$attachment->{data} = $buf if $id == ATTACH_DATA; $buf =~ s/[\0\s]+$//;
	$attachment->{filename} = $buf if $id == ATTACH_FILENAME;
	return 1;
}

# vi:set ts=4 sw=4:
